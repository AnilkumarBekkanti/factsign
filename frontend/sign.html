<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 2: Sign Document</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- PDF Rendering Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- NEW: PDF Generation/Modification Library -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    <style>
        /* CSS is unchanged */
        :root { --primary-color: #4a6fa5; --secondary-color: #166088; --accent-color: #4fc3f7; --light-color: #f8f9fa; --dark-color: #343a40; --success-color: #28a745; --error-color: #dc3545; --border-radius: 8px; --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); --transition: all 0.3s ease; }
        body { font-family: 'Roboto', sans-serif; background-color: #f5f7fa; color: var(--dark-color); }
        .container { max-width: 90%; margin: 2rem auto; }
        #document-viewer { background-color: #e9ecef; border: 1px solid #ced4da; border-radius: var(--border-radius); overflow-y: auto; height: 85vh; position: relative; text-align: center; }
        .page-container { position: relative; display: inline-block; margin: 1rem auto; }
        .page-container canvas, .page-container img { display: block; box-shadow: var(--box-shadow); }
        .placeholder { position: absolute; width: 180px; height: 40px; background-color: rgba(255, 193, 7, 0.3); border: 2px dashed #ffc107; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; color: #856404; font-weight: 500; user-select: none; transition: background-color 0.3s ease; }
        .placeholder:hover { background-color: rgba(255, 193, 7, 0.5); }
        .placeholder.signed { display: none; }
        .signature-wrapper { position: absolute; border: 1px dashed var(--accent-color); cursor: move; user-select: none; }
        .signature-wrapper .signature-image { width: 100%; height: 100%; pointer-events: none; }
        .resize-handle { position: absolute; width: 12px; height: 12px; background: var(--accent-color); border: 2px solid white; border-radius: 50%; right: -8px; bottom: -8px; cursor: se-resize; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-content { background: white; padding: 2rem; border-radius: var(--border-radius); text-align: center; }
        .upload-signature-btn { background-color: var(--primary-color); color: white; border: none; padding: 0.75rem 1.5rem; font-size: 1rem; border-radius: var(--border-radius); cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem; }
        .upload-signature-btn:hover { background-color: var(--secondary-color); }
        #cancel-upload { background-color: #6c757d; margin-top: 1rem; }
        #finish-btn { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 1rem 2rem; font-size: 1.2rem; background-color: var(--success-color); color: white; border: none; border-radius: 50px; box-shadow: var(--box-shadow); cursor: pointer; z-index: 50; }
        #finish-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
    </style>
</head>
<body>
    <!-- HTML is unchanged -->
    <div class="container" id="main-content">
        <h1 id="doc-title" style="text-align: center; margin-bottom: 1rem;"></h1>
        <div id="document-viewer"><p style="padding-top: 2rem;">Loading document...</p></div>
        <button id="finish-btn" style="display: none;" disabled>Finish & Submit</button>
    </div>
    <div class="modal-overlay" id="signature-modal" style="display: none;">
        <div class="modal-content">
            <h3>Upload Signature Image</h3>
            <p style="margin-bottom: 1.5rem; color: #6c757d;">SVG format is recommended for best quality.</p>
            <button class="upload-signature-btn" id="upload-btn"><i class="fas fa-upload"></i> Choose File</button>
            <input type="file" id="signature-image-input" accept="image/svg+xml,image/png,image/jpeg" style="display: none;">
            <br>
            <button class="upload-signature-btn" id="cancel-upload">Cancel</button>
        </div>
    </div>
    
<script>
document.addEventListener('DOMContentLoaded', async () => {
    // --- ELEMENT SELECTIONS and STATE VARIABLES ---
    // (unchanged)
    const docTitleEl = document.getElementById('doc-title'), documentViewer = document.getElementById('document-viewer');
    const signatureModal = document.getElementById('signature-modal'), uploadBtn = document.getElementById('upload-btn');
    const signatureImageInput = document.getElementById('signature-image-input'), cancelUploadBtn = document.getElementById('cancel-upload');
    const finishBtn = document.getElementById('finish-btn');
    let documentData, currentPlaceholderId = null;
    let appliedSignatures = [];
    let activeInteraction = { type: null, target: null, startX: 0, startY: 0, startW: 0, startH: 0, startLeft: 0, startTop: 0 };
    
    // --- INITIALIZATION ---
    // (unchanged)
    try {
        const params = new URLSearchParams(window.location.search);
        
        const docId = params.get('docId');
        if (!docId) throw new Error("No document ID provided.");
        const storedData = localStorage.getItem(docId);
        if (!storedData) throw new Error(`Document with ID '${docId}' not found.`);
        documentData = JSON.parse(storedData);
        docTitleEl.textContent = documentData.title;
        await renderDocument();
        renderPlaceholders();
    } catch (error) {
        console.error("Initialization failed:", error);
        documentViewer.innerHTML = `<p style="color: var(--error-color); padding: 2rem;">${error.message}</p>`;
        return;
    }

    // --- EVENT LISTENERS ---
    // The finishBtn listener is now updated
    uploadBtn.addEventListener('click', () => signatureImageInput.click());
    cancelUploadBtn.addEventListener('click', () => signatureModal.style.display = 'none');
    signatureImageInput.addEventListener('change', handleImageUpload);
    document.addEventListener('mousedown', startInteraction);
    document.addEventListener('mousemove', handleInteraction);
    document.addEventListener('mouseup', endInteraction);
    
    finishBtn.addEventListener('click', async () => {
        finishBtn.disabled = true;
        finishBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Processing...`;
        try {
            await generateFinalPdf();
            alert('Your signed document has been downloaded!');
            localStorage.removeItem(documentData.id);
            document.getElementById('main-content').innerHTML = '<h2 style="text-align:center; color: var(--success-color); padding:3rem;">Thank You! The document has been submitted.</h2>';
        } catch (err) {
            console.error("Failed to generate PDF:", err);
            alert("An error occurred while generating the PDF. Please try again.");
            finishBtn.disabled = false;
            finishBtn.textContent = 'Finish & Submit';
        }
    });

    // --- PDF GENERATION ---
    async function generateFinalPdf() {
        const { PDFDocument } = PDFLib;
        let pdfDoc;

        // Step 1: Load the original document
        if (documentData.fileType === 'application/pdf') {
            pdfDoc = await PDFDocument.load(documentData.file);
        } else { // It's an image
            pdfDoc = await PDFDocument.create();
            const imageBytes = documentData.file;
            let embeddedImage;
            if (documentData.fileType === 'image/jpeg' || documentData.fileType === 'image/jpg') {
                embeddedImage = await pdfDoc.embedJpg(imageBytes);
            } else { // Assume PNG
                embeddedImage = await pdfDoc.embedPng(imageBytes);
            }
            const page = pdfDoc.addPage([embeddedImage.width, embeddedImage.height]);
            page.drawImage(embeddedImage, { x: 0, y: 0, width: embeddedImage.width, height: embeddedImage.height });
        }
        
        // Step 2: Embed signature images and draw them on pages
        const pages = pdfDoc.getPages();
        for (const sig of appliedSignatures) {
            const page = pages[sig.page - 1];
            if (!page) continue;

            const sigImage = await pdfDoc.embedPng(sig.dataUrl); // Signatures are always PNG

            // Step 3: Coordinate Conversion (CRITICAL)
            // Get dimensions of the PDF page in points (72 points = 1 inch)
            const { width: pageWidth, height: pageHeight } = page.getSize();
            // Get dimensions of the rendered element on screen in pixels
            const renderedPageElement = documentViewer.querySelector(`[data-page-number="${sig.page}"]`);
            const renderedWidth = renderedPageElement.width;
            const renderedHeight = renderedPageElement.height;
            
            // Calculate scaling factors
            const scaleX = pageWidth / renderedWidth;
            const scaleY = pageHeight / renderedHeight;
            
            // Apply scaling to the signature's position and dimensions
            const finalX = sig.x * scaleX;
            const finalWidth = sig.width * scaleX;
            const finalHeight = sig.height * scaleY;

            // Invert the Y-coordinate because web (0,0) is top-left, PDF (0,0) is bottom-left
            const finalY = pageHeight - (sig.y * scaleY) - finalHeight;

            page.drawImage(sigImage, {
                x: finalX,
                y: finalY,
                width: finalWidth,
                height: finalHeight,
            });
        }

        // Step 4: Serialize the PDF and trigger download
        const pdfBytes = await pdfDoc.save();
        const cleanTitle = documentData.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        download(pdfBytes, `${cleanTitle}_signed.pdf`, "application/pdf");
    }

    function download(data, filename, type) {
        const blob = new Blob([data], { type: type });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.style.display = "none";
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
    }
    
    // --- ALL OTHER FUNCTIONS ARE UNCHANGED FROM THE PREVIOUS CORRECT VERSION ---
    // (They are included here to make this a complete, single-file solution)
    async function renderDocument() { /* ... */ }
    async function renderPdf(typedarray) { /* ... */ }
    function renderImage(fileDataUrl) { /* ... */ }
    function renderPlaceholders() { /* ... */ }
    function handleImageUpload(e) { /* ... */ }
    function startInteraction(e) { /* ... */ }
    function handleInteraction(e) { /* ... */ }
    function endInteraction(e) { /* ... */ }
    function renderAppliedSignatures() { /* ... */ }
    function updateFinishButtonState() { /* ... */ }

    // --- PASTE THE FULL IMPLEMENTATION OF THE UNCHANGED FUNCTIONS HERE ---
    async function renderDocument() { documentViewer.innerHTML = ''; if (documentData.fileType === 'application/pdf') { const raw = window.atob(documentData.file.split(',')[1]); const rawLength = raw.length; const array = new Uint8Array(new ArrayBuffer(rawLength)); for(let i = 0; i < rawLength; i++) array[i] = raw.charCodeAt(i); return renderPdf(array); } else { return renderImage(documentData.file); } }
    async function renderPdf(typedarray) { const pdf = await pdfjsLib.getDocument(typedarray).promise; const renderPromises = []; for (let i = 1; i <= pdf.numPages; i++) { const renderPromise = pdf.getPage(i).then(page => { const viewport = page.getViewport({ scale: 1.5 }); const pageContainer = document.createElement('div'); pageContainer.className = 'page-container'; pageContainer.style.width = viewport.width + 'px'; const canvas = document.createElement('canvas'); canvas.dataset.pageNumber = i; canvas.height = viewport.height; canvas.width = viewport.width; pageContainer.appendChild(canvas); documentViewer.appendChild(pageContainer); return page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise; }); renderPromises.push(renderPromise); } return Promise.all(renderPromises); }
    function renderImage(fileDataUrl) { return new Promise((resolve, reject) => { const pageContainer = document.createElement('div'); pageContainer.className = 'page-container'; const img = document.createElement('img'); img.dataset.pageNumber = 1; img.onload = () => { documentViewer.appendChild(pageContainer); resolve(); }; img.onerror = () => reject(new Error("Failed to load signature image.")); pageContainer.appendChild(img); img.src = fileDataUrl; }); }
    function renderPlaceholders() { if (!documentData.placeholders) return; documentData.placeholders.forEach(p => { const pageElement = documentViewer.querySelector(`[data-page-number="${p.page}"]`); if(!pageElement) { console.error(`Could not find page element for page ${p.page}`); return; } const pageContainer = pageElement.parentElement; const el = document.createElement('div'); el.className = 'placeholder'; el.dataset.id = p.id; el.innerHTML = `<i class="fas fa-image"></i> Click to Add Signature`; el.style.left = `${p.x}px`; el.style.top = `${p.y}px`; el.addEventListener('click', () => { if (el.classList.contains('signed')) return; currentPlaceholderId = p.id; signatureModal.style.display = 'flex'; }); pageContainer.appendChild(el); }); finishBtn.style.display = 'block'; }
    function handleImageUpload(e) { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { const dataUrl = event.target.result; const placeholder = document.querySelector(`.placeholder[data-id="${currentPlaceholderId}"]`); const placeholderRect = placeholder.getBoundingClientRect(); const img = new Image(); img.onload = () => { appliedSignatures.push({ id: 'sig_' + Date.now(), placeholderId: currentPlaceholderId, dataUrl: dataUrl, x: placeholder.offsetLeft, y: placeholder.offsetTop, width: placeholderRect.width, height: placeholderRect.height, page: parseInt(placeholder.parentElement.querySelector('canvas,img').dataset.pageNumber, 10), aspectRatio: img.naturalWidth / img.naturalHeight }); signatureModal.style.display = 'none'; renderAppliedSignatures(); updateFinishButtonState(); }; img.src = dataUrl; }; reader.readAsDataURL(file); e.target.value = ''; }
    function startInteraction(e) { if (e.target.classList.contains('signature-wrapper')) { activeInteraction.type = 'move'; activeInteraction.target = e.target; } else if (e.target.classList.contains('resize-handle')) { activeInteraction.type = 'resize'; activeInteraction.target = e.target.parentElement; } else { return; } e.preventDefault(); const signatureData = appliedSignatures.find(s => s.id === activeInteraction.target.dataset.id); activeInteraction.startX = e.clientX; activeInteraction.startY = e.clientY; activeInteraction.startW = signatureData.width; activeInteraction.startH = signatureData.height; activeInteraction.startLeft = signatureData.x; activeInteraction.startTop = signatureData.y; }
    function handleInteraction(e) { if (!activeInteraction.type) return; e.preventDefault(); const dx = e.clientX - activeInteraction.startX; const dy = e.clientY - activeInteraction.startY; let signatureData = appliedSignatures.find(s => s.id === activeInteraction.target.dataset.id); if (activeInteraction.type === 'move') { signatureData.x = activeInteraction.startLeft + dx; signatureData.y = activeInteraction.startTop + dy; } else if (activeInteraction.type === 'resize') { const newWidth = activeInteraction.startW + dx; if (newWidth > 20) { signatureData.width = newWidth; signatureData.height = newWidth / signatureData.aspectRatio; } } activeInteraction.target.style.left = signatureData.x + 'px'; activeInteraction.target.style.top = signatureData.y + 'px'; activeInteraction.target.style.width = signatureData.width + 'px'; activeInteraction.target.style.height = signatureData.height + 'px'; }
    function endInteraction(e) { if (!activeInteraction.type) return; activeInteraction.type = null; activeInteraction.target = null; }
    function renderAppliedSignatures() { document.querySelectorAll('.signature-wrapper').forEach(w => w.remove()); appliedSignatures.forEach(sig => { const pageContainer = documentViewer.querySelector(`[data-page-number="${sig.page}"]`).parentElement; if (!pageContainer) return; const wrapper = document.createElement('div'); wrapper.className = 'signature-wrapper'; wrapper.dataset.id = sig.id; wrapper.style.left = sig.x + 'px'; wrapper.style.top = sig.y + 'px'; wrapper.style.width = sig.width + 'px'; wrapper.style.height = sig.height + 'px'; const img = document.createElement('img'); img.src = sig.dataUrl; img.className = 'signature-image'; const handle = document.createElement('div'); handle.className = 'resize-handle'; wrapper.appendChild(img); wrapper.appendChild(handle); pageContainer.appendChild(wrapper); const originalPlaceholder = document.querySelector(`.placeholder[data-id="${sig.placeholderId}"]`); if (originalPlaceholder) originalPlaceholder.classList.add('signed'); }); }
    function updateFinishButtonState() { const signedCount = new Set(appliedSignatures.map(s => s.placeholderId)).size; finishBtn.disabled = signedCount < documentData.placeholders.length; }

});
</script>
</body>
</html>